Index: ../src/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>require('dotenv').config();\r\nconst express = require(\"express\");\r\nconst axios = require(\"axios\");\r\nconst mysql = require('mysql2');\r\nconst crypto = require('crypto');\r\nconst { Client, IntentsBitField, GuildMember } = require('discord.js');\r\nconst { REST } = require('@discordjs/rest');\r\nconst { Routes } = require('discord-api-types/v10');\r\nconst { rejects } = require('assert');\r\n\r\n// const secretKey = crypto.randomBytes(32);\r\n\r\nconst hash = crypto.createHash('sha256');\r\nhash.update(process.env.secretKey);\r\nconst secretKey = hash.digest();\r\n\r\nconst client = new Client({\r\n  intents: [\r\n    IntentsBitField.Flags.Guilds,\r\n    IntentsBitField.Flags.GuildMembers,\r\n    IntentsBitField.Flags.GuildMessages,\r\n    IntentsBitField.Flags.MessageContent,\r\n  ],\r\n});\r\n\r\nconst roleNumberBachelor = {\r\n  \"Първи Курс - Бакалавър\" : 1,\r\n  \"Втори Курс - Бакалавър\" : 2,\r\n  \"Трети Курс - Бакалавър\" : 3,\r\n  \"Четвърти Курс - Бакалавър\" : 4\r\n}\r\n\r\nconst bachelorRoles = {\r\n  \"1\" : \"Първи Курс - Бакалавър\",\r\n  \"2\" : \"Втори Курс - Бакалавър\",\r\n  \"3\" : \"Трети Курс - Бакалавър\",\r\n  \"4\" :\"Четвърти Курс - Бакалавър\"\r\n}\r\n\r\nconst masterRoles = {\r\n  \"1\" : \"Първи Курс - Магистър\",\r\n  \"2\" : \"Втори Курс - Магистър\",\r\n  \"3\" : \"Трети Курс - Магистър\",\r\n  \"4\" :\"Четвърти Курс - Магистър\"\r\n}\r\n\r\nconst commands = [\r\n  {\r\n    name: 'auth',\r\n    description: 'Gives user an auth link to moodle',\r\n  },\r\n];\r\n\r\nconst rest = new REST({ version: '10' }).setToken(process.env.TOKEN);\r\n\r\n\r\nconst registerCommands = async (guildId) => {\r\n  try {\r\n    console.log(`Registering commands for guild: ${guildId}`);\r\n    await rest.put(\r\n      Routes.applicationGuildCommands(process.env.CLIENT_ID, guildId),\r\n      { body: commands },\r\n    );\r\n    console.log('Commands registered successfully.');\r\n  } catch (error) {\r\n    console.error(`Error registering commands for guild ${guildId}:`, error);\r\n  }\r\n};\r\n\r\n\r\n\r\nclient.on('ready', (c) => {\r\n  console.log(`✅ ${c.user.tag} is online.`);\r\n});\r\n\r\nclient.on('interactionCreate', async (interaction) => {\r\n  if (!interaction.isChatInputCommand()) return;\r\n\r\n  if (interaction.commandName === 'auth') {\r\n\r\n    const encryptedDiscord = encryptToURLSafe(interaction.user.id, secretKey);\r\n    const encryptedGuild = encryptToURLSafe(interaction.guild.id, secretKey)\r\n\r\n  interaction.user.send(`http://localhost/local/oauth/login.php?client_id=ClientId1&response_type=code&discord_id=${encryptedDiscord}&guild_id=${encryptedGuild}`);\r\n\r\n  return 0;\r\n  }\r\n\r\n});\r\n\r\nclient.on('guildCreate', (guild) => {\r\n  // When the bot joins a new server, register commands for that server\r\n  registerCommands(guild.id);\r\n});\r\n\r\n\r\nclient.login(process.env.TOKEN);\r\n\r\n// Encryption function\r\nfunction encryptToURLSafe(text, secretKey) {\r\n  const iv = crypto.randomBytes(16);\r\n  const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(secretKey), iv);\r\n  let encrypted = cipher.update(text);\r\n  encrypted = Buffer.concat([encrypted, cipher.final()]);\r\n\r\n  const ivBase64 = iv.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n  const encryptedBase64 = encrypted.toString('base64').replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\r\n\r\n  return `${ivBase64}:${encryptedBase64}`;\r\n}\r\n\r\n// Decryption function\r\nfunction decryptFromURLSafe(encryptedURLSafe, secretKey) {\r\n  const parts = encryptedURLSafe.split(':');\r\n  const iv = Buffer.from(parts[0].replace(/-/g, '+').replace(/_/g, '/'), 'base64');\r\n  const encryptedText = Buffer.from(parts[1].replace(/-/g, '+').replace(/_/g, '/'), 'base64');\r\n  const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(secretKey), iv);\r\n  let decrypted = decipher.update(encryptedText);\r\n  decrypted = Buffer.concat([decrypted, decipher.final()]);\r\n  return decrypted.toString();\r\n}\r\n\r\nfunction setRole(role,discordID,member,guild){\r\n// Fetch the member asynchronously\r\nguild.members.fetch(discordID)\r\n.then(member => {\r\n  // Check if the member is found\r\n  if (member) {\r\n    // Add the role to the member\r\n    member.roles.add(role)\r\n      .then(() => {\r\n        console.log(`Added role ${role.name} to user ${member.user.tag}`);\r\n      })\r\n      .catch(error => {\r\n        console.error(`Error adding role: ${error}`);\r\n      });\r\n  } else {\r\n    console.error(`Member not found with ID: ${discordID}`);\r\n  }\r\n})\r\n.catch(error => {\r\n  console.error(`Error fetching member: ${error}`);\r\n});\r\n\r\n}\r\n\r\nfunction setName(discordID,username,guild){\r\n  console.log(discordID);\r\n  guild.members.fetch(discordID)\r\n  .then(member => {\r\n    // Check if the member is found\r\n    if (member) {\r\n     \r\n      // Change the username (nickname) of the member\r\n      member.setNickname(username)\r\n        .then(() => {\r\n          console.log(`Changed username to ${username} for user ${member.user.tag}`);\r\n        })\r\n        .catch(error => {\r\n          console.error(`Error changing username: ${error}`);\r\n        });\r\n      }\r\n    });\r\n\r\n}\r\n\r\nasync function facultyDB(faculty) {\r\n  const connection = mysql.createConnection({\r\n    host: '127.0.0.1',\r\n    port: 4300, // Port should be a number, not a string\r\n    user: 'root',\r\n    password: 'Admin123!',\r\n    database: 'uis_student'\r\n  });\r\n\r\n  // Return a new Promise\r\n  return new Promise((resolve, reject) => {\r\n    connection.connect();\r\n\r\n    connection.query(\r\n      'SELECT Major FROM guilddata WHERE guildName = ?',\r\n      [faculty],\r\n      (error, results) => {\r\n        connection.end(); // Make sure to end the connection after the query\r\n\r\n        if (error) {\r\n          reject(error); // Reject the Promise if there is an error\r\n        } else {\r\n          resolve(results); // Resolve the Promise with the results\r\n        }\r\n      }\r\n    );\r\n  });\r\n}\r\n\r\nasync function discrordDBCheck(facultyNumber){\r\n  const connection = mysql.createConnection({\r\n    host: '127.0.0.1',\r\n    port: 4300, // Port should be a number, not a string\r\n    user: 'root',\r\n    password: 'Admin123!',\r\n    database: 'uis_student'\r\n  });\r\n\r\n  return new Promise((resolve, reject) =>{\r\n    connection.connect();\r\n\r\n    connection.query(\r\n      'SELECT Id FROM students WHERE FacultyNumber = ?',\r\n      [facultyNumber],\r\n      (error, results) =>{\r\n        connection.end();\r\n  \r\n        if(error){\r\n          reject(error);\r\n        }else{\r\n          resolve(results);\r\n        }\r\n      }\r\n  \r\n    )\r\n\r\n  })\r\n\r\n}\r\n\r\n\r\nconst app = express();\r\nconst PORT = 4200;\r\n\r\napp.use(express.json());\r\napp.use(express.urlencoded({ extended: true }));\r\n\r\n// Middleware to log when the endpoint is hit\r\napp.use('/api/User/discord-info', (req, res, next) => {\r\n  console.log('Received something at /api/User/discord-info');\r\n  next(); // Pass control to the next middleware\r\n});\r\n\r\nasync function getGuildById(guildID,client) {\r\n  try {\r\n      const guild = await client.guilds.fetch(guildID);\r\n      return guild;\r\n  } catch (error) {\r\n      console.error(`Error fetching guild: ${error.message}`);\r\n      return null;\r\n  }\r\n}\r\n\r\nasync function getCourseRole(courseName,myguild) {\r\n  try {\r\n    let role = await myguild.roles.cache.find((n=> n.name === courseName));\r\n    return role;\r\n  }catch(error){\r\n    console.error(`Error getting role: ${error.message}`);\r\n  }\r\n}\r\n\r\nasync function getUser(discordID,myguild){\r\n  const user = await myguild.members.fetch(discordID);\r\n\r\n  return user;\r\n}\r\n\r\nasync function removeRoles(discordID,role,myguild){\r\n  const roleAsNumber = roleNumberBachelor[role];\r\n  myguild.members.fetch(discordID)\r\n  .then(member=>{\r\n    const allRoles = member.roles.cache;\r\n    allRoles.forEach(element => {\r\n      const currentRole = roleNumberBachelor[element.name];\r\n      if(roleAsNumber < currentRole){\r\n        member.roles.remove(element)\r\n        console.log(`Role ${element.name} removed for ${member.user.tag}`);\r\n      }\r\n    });\r\n  })\r\n}\r\n\r\nasync function removeBachelorRoles(discordID,myguild){\r\n  myguild.members.fetch(discordID)\r\n  .then(member=>{\r\n    const allRoles = member.roles.cache;\r\n\r\n    allRoles.forEach(element=>{\r\n      for (const [key, value] of Object.entries(bachelorRoles)) {\r\n        if (element.name === value){\r\n          member.roles.remove(element);\r\n          console.log(`Removed bachelor role ${element.name}`);\r\n        }\r\n      }\r\n    })\r\n\r\n  })\r\n}\r\n\r\n// Function to insert data into discorddata table\r\nfunction insertIntoDiscordData(discordData) {\r\n  const connection = mysql.createConnection({\r\n    host: '127.0.0.1',\r\n    port: 4300, // Port should be a number, not a string\r\n    user: 'root',\r\n    password: 'Admin123!',\r\n    database: 'uis_student'\r\n  });\r\n\r\n  const sql = 'INSERT INTO discorddata SET ?';\r\n  connection.query(sql, discordData, (error, results) => {\r\n    if (error) {\r\n      console.error('Error occurred:', error);\r\n      return;\r\n    }\r\n    console.log('Insert successful:', results);\r\n  });\r\n}\r\n\r\n// Your route handling\r\napp.post('/api/User/discord-info', (req, res) => {\r\n  const firstName = req.body.firstname;\r\n  const lastName = req.body.lastname;\r\n  const courseNumber = req.body.course_number;\r\n  const facultyNumber = req.body.faculty_number;\r\n  const discordID = decryptFromURLSafe(req.body.discord_id,secretKey);\r\n  const guildID  = decryptFromURLSafe(req.body.guild_id,secretKey);\r\n  const degree = req.body.degree;\r\n  const major = req.body.major;\r\n  const username = `${firstName} ${lastName} (${courseNumber}. курс)`;\r\n\r\ndiscrordDBCheck(facultyNumber).then(resultDB=>{\r\nif (resultDB != \"\"){\r\n  DBdata = {\r\n    \"Id\": null,\r\n    \"StudentId\": resultDB[0].Id,\r\n    \"DiscordId\" : discordID,\r\n    \"GuildId\": guildID\r\n  };\r\n  insertIntoDiscordData(DBdata);\r\n\r\n   // Use .then to handle the asynchronous operation\r\n   getGuildById(guildID, client)\r\n   .then(myguild => {\r\n     // Continue with the rest of your code using myguild\r\n     if (myguild) {\r\n       res.status(200).json({ success: true });\r\n\r\n       \r\n     \r\n      //  const member = myguild.members.cache.get(discordID);\r\n\r\n      getUser(discordID,myguild).then(member=>{\r\n        \r\n\r\n        try {\r\n          facultyDB(major).then(name_1=>{\r\n            console.log(`I am here and dbresult is ${name_1[0].Major}`)\r\n            if(name_1[0].Major != myguild.name){\r\n              console.log(`My guild name is: ${myguild.name}`)\r\n              let roles = member.roles.cache.filter(r => r.id !== myguild.id); // Get all roles except @everyone\r\n              member.roles.remove(roles); // Remove all roles\r\n              console.log('Major and server do not match');\r\n            }else{\r\n              setName(discordID,username,myguild);\r\n              if(degree === \"Бакалавър\"){\r\n                const role = bachelorRoles[courseNumber];\r\n               getCourseRole(role,myguild).then(role =>{\r\n                setRole(role,discordID,member,myguild);\r\n              }) \r\n\r\n               removeRoles(discordID,role,myguild)\r\n\r\n              }else if(degree === \"Магистър\"){\r\n\r\n                const role = masterRoles[courseNumber];\r\n                getCourseRole(role,myguild).then(role =>{\r\n                  setRole(role,discordID,member,myguild);\r\n              })\r\n              removeBachelorRoles(discordID,myguild);\r\n              \r\n            }\r\n            }\r\n          })\r\n         }catch(error){\r\n          console.error(error);\r\n         }\r\n     \r\n \r\n      })\r\n       \r\n       console.log('Received form data:', { firstName, lastName, facultyNumber: courseNumber});\r\n     \r\n      //  // Send a response if needed\r\n      //  res.send('Data received successfully!');\r\n\r\n     } else {\r\n       res.status(404).json({ success: false, error: 'Guild not found' });\r\n     }\r\n   })\r\n   .catch(error => {\r\n     console.error(`Error in route handler: ${error.message}`);\r\n     res.status(500).json({ success: false, error: 'Internal Server Error' });\r\n   });\r\n}\r\n})\r\n\r\n\r\n});\r\n\r\napp.listen(PORT, () => {\r\n  console.log(`Server is running on http://localhost:${PORT}`);\r\n});
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../src/index.js b/../src/index.js
--- a/../src/index.js	(revision 86e45c95e1d5b864bda6a215cbfb0b3a99bd5510)
+++ b/../src/index.js	(date 1702820964360)
@@ -49,6 +49,10 @@
     name: 'auth',
     description: 'Gives user an auth link to moodle',
   },
+  {
+    name: 'sync',
+    description: 'Syncs all users from the server'
+  }
 ];
 
 const rest = new REST({ version: '10' }).setToken(process.env.TOKEN);
@@ -84,9 +88,15 @@
   interaction.user.send(`http://localhost/local/oauth/login.php?client_id=ClientId1&response_type=code&discord_id=${encryptedDiscord}&guild_id=${encryptedGuild}`);
 
   return 0;
+  }else if (interaction.commandName === 'sync') {
+    
+
   }
 
 });
+
+
+
 
 client.on('guildCreate', (guild) => {
   // When the bot joins a new server, register commands for that server
Index: ../.env
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>TOKEN = MTE3MTAyMzEzMzM0MDMzNjE1MQ.GNCTY1.Ja6mMhe-4YmCOh8QcP394Kv-Ijfd8u2xZmQXhs\r\nGUILD_ID = 1160634183706738791\r\nCLIENT_ID = 1171023133340336151
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/../.env b/../.env
--- a/../.env	(revision 86e45c95e1d5b864bda6a215cbfb0b3a99bd5510)
+++ b/../.env	(date 1702738051590)
@@ -1,3 +1,4 @@
-TOKEN = MTE3MTAyMzEzMzM0MDMzNjE1MQ.GNCTY1.Ja6mMhe-4YmCOh8QcP394Kv-Ijfd8u2xZmQXhs
+TOKEN = MTE3MTAyMzEzMzM0MDMzNjE1MQ.GfUive.OTsEr0TNFiUA79mVZo51zQMCNvP61xEUxdK7G0
 GUILD_ID = 1160634183706738791
-CLIENT_ID = 1171023133340336151
\ No newline at end of file
+CLIENT_ID = 1171023133340336151
+secretKey = WeLoveSasho
\ No newline at end of file
